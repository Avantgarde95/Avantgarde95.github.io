{"pageProps":{"output":{"key":"crtp","title":"CRTP (Curiously Recurring Template Pattern)","time":1623283200000,"category":"Computer","content":"<p>C++에서 <strong>CRTP</strong>(묘하게 되풀이되는 템플릿 패턴, Curiously Recurring Template Pattern)라는 재미있는 트릭이 있다.\n부모 클래스를 템플릿 클래스로 만들고 자식 클래스가 자기 자신을 템플릿 인수로 넣어 부모 클래스에서 자식 클래스를 사용할 수 있게 하는 트릭이다.</p>\n<p>There&#39;s a fun trick in C++ called CRTP (Curiously Recurring Template Pattern).\nThe trick is to enable the parent class to use the child class by making the parent class a template class and let the child class to pass itself as a template argument.</p>\n<pre><code class=\"language-cpp\"><span class=\"hljs\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> Derived&gt;\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyBase</span> {\n    ...\n};\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyDerived</span>: <span class=\"hljs-keyword\">public</span> MyBase&lt;Derived&gt; {\n    ...\n};</span>\n</code></pre>\n<p>이 트릭을 이용하면 아래와 같이 싱글톤 베이스 클래스를 제작할 수 있다.\n자식 클래스에서 <code>getInstance()</code>를 굳이 만들 필요 없이 싱글톤 베이스 클래스를 상속받고 생성자만 구현해주면 된다.\n개인적으로 안정성이 중요한 프로그램들에서 싱글톤들의 라이프사이클을 일괄적으로 관리하고 싶을때 매우 유용하지 않을까 생각한다.</p>\n<p>Using this trick, you can create a singleton base class like below.\nThe child class doesn&#39;t have to create its own <code>getInstance()</code>. I just need to inherit the singleton base class and implement its constructor.\nPersonally, I think it would be very useful when you want to manage the lifecycle of singletons in the programs where stability is important.</p>\n<pre><code class=\"language-cpp\"><span class=\"hljs\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> Derived&gt;\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Singleton</span> {\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> Derived* <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (m_instance == <span class=\"hljs-literal\">nullptr</span>) {\n            <span class=\"hljs-comment\">// Call the constructor of the child class (by using CRTP).</span>\n            m_instance = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Derived</span>();\n        }\n\n        <span class=\"hljs-keyword\">return</span> m_instance;\n    }\n\n<span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-type\">static</span> Derived* m_instance;\n};\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> Derived&gt;\nDerived* Singleton&lt;Derived&gt;::m_instance = <span class=\"hljs-literal\">nullptr</span>;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Manager</span> : <span class=\"hljs-keyword\">public</span> Singleton&lt;Manager&gt; {\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-built_in\">Manager</span>() {\n        m_status = <span class=\"hljs-string\">&quot;Manager is created!&quot;</span>;\n    }\n\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-function\"><span class=\"hljs-type\">const</span> std::string&amp; <span class=\"hljs-title\">getStatus</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{\n        <span class=\"hljs-keyword\">return</span> m_status;\n    }\n\n<span class=\"hljs-keyword\">private</span>:\n    std::string m_status;\n};</span>\n</code></pre>\n"}},"__N_SSG":true}
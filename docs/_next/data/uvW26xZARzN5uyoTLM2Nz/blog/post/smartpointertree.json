{"pageProps":{"postKey":"smartpointertree","post":{"title":"Creating a tree using the smart pointer","time":1618185600000,"category":"Computer","content":"C++에서 트리를 만들때, 스마트 포인터 `std::shared_ptr`를 활용하면 자식 노드의 메모리 해제를 직접 해주지 않아도 될 뿐만 아니라 여러 트리가 한 노드를 참조하는 상황에서도 알아서 메모리가 해제되도록 할 수 있다.\n\nWhen creating a tree in C++, if you use the smart pointer `std::shared_ptr`, you don't have to release the memory of each child node directly, and you can let the program to automatically release the memory even when multiple trees refer to one node.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <memory>\n\nclass Node {\npublic:\n    Node(const std::string& name): m_name(name) {\n        // Do nothing.\n    }\n\n    void print(int level = 0) {\n        printThis(level);\n        printChilds(level);\n    }\n\n    void addChild(const std::shared_ptr<Node>& child) {\n        m_childs.push_back(child);\n    }\n\nprivate:\n    void printThis(int level) {\n        std::stringstream ss;\n\n        for (int i = 0; i < level - 1; i++) {\n            ss << \"   \";\n        }\n\n        if (level > 0) {\n            ss << \"|- \";\n        }\n\n        ss << m_name << \"\\n\";\n        std::cout << ss.str();\n    }\n\n    void printChilds(int level) {\n        for (auto child: m_childs) {\n            child->print(level + 1);\n        }\n    }\n\nprivate:\n    std::string m_name;\n    std::vector<std::shared_ptr<Node>> m_childs;\n};\n```\n\n아래와 같이 트리 두 개를 만들어 보자. 두 트리는 노드 4를 공유한다.\n\nLet's create two trees as shown below. The trees share node 4.\n\n**Tree**\n\n```\nTree 1: 0 - 1 - 2\n            |\n            3 - 4 - 5\n                |\nTree 2: 6 ------+\n                |\n                7 - 8\n                |\n                9 - 10 - 11\n```\n\n**Code**\n\n```cpp\nint main() {\n    std::vector<std::shared_ptr<Node>> nodes;\n\n    for (int i = 0; i <= 11; i++) {\n        nodes.push_back(std::make_shared<Node>(std::to_string(i)));\n    }\n\n    // Tree 1.\n    nodes[0]->addChild(nodes[1]);\n    nodes[0]->addChild(nodes[3]);\n    nodes[1]->addChild(nodes[2]);\n    nodes[3]->addChild(nodes[4]);\n    nodes[4]->addChild(nodes[5]);\n\n    // Tree 2.\n    nodes[6]->addChild(nodes[4]);\n    nodes[6]->addChild(nodes[7]);\n    nodes[6]->addChild(nodes[9]);\n    nodes[7]->addChild(nodes[8]);\n    nodes[9]->addChild(nodes[10]);\n    nodes[10]->addChild(nodes[11]);\n\n    nodes[0]->print();\n    nodes[6]->print();\n\n    return 0;\n}\n```\n\n프로그램은 아래와 같은 결과를 출력할 것이다.\n[Valgrind](https://valgrind.org/)를 사용하여 메모리 누수가 없음을 확인할 수 있다.\n\nThe program will print the following output.\nYou can use [Valgrind](https://valgrind.org/) to confirm that there is no memory leak.\n\n```\n0\n|- 1\n   |- 2\n|- 3\n   |- 4\n      |- 5\n6\n|- 4\n   |- 5\n|- 7\n   |- 8\n|- 9\n   |- 10\n      |- 11\n```\n"}},"__N_SSG":true}